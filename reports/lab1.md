#### 简答题

1. 如何去测试这几个？？？
2. `__alltraps` 和 `__restore` 的作用
   1. a0表示TrapContext的地址，也就是要加载到寄存器中的内容。
      __restore使用场景：
      + 在trap控制流中，此时位于S态，需要恢复之前暂存的U态的数据。
      + 处于S态时，此时需要切换当前运行的应用，通过__restore 返回到用户态
   2. sstatus: 记录trap发生之前，是处在U态
      sepc: 回到U态后，下面是执行那条指令
      sscratch: 当还处在S态时，sscratch保存了进入S态之前U态用户栈栈顶指针的位置。
   3. x4: 我们这里没有用到它(它只有一些特殊用途才会用到)
      x2: x2即sp寄存器，此时它已经指向了内核栈，所以这里不需要保存，而是在后面从sscratch那去读取保存
   4. sp: 进入trap之前的用户栈的栈顶指针
      sscratch: 指向内核栈，且栈顶指针指向栈底
   5. sret指令，因为sepc指向了U态的指令，sret使得pc指向了sepc所在的值, 且sstatus.SPP为U态（因为恢复到了产生trap之前的状态）
   6. sp: 指向内核栈，且栈顶指针位于内核栈的顶端
      sscratch: 指向用户栈，且栈顶指针和进入trap之前的栈顶指针一致
   7. ecall

#### 总结

添加了记录当前运行时间的功能以及记录不同系统调用次数的功能

+ 初始化任务的时候，start_time = -1

  当任务第一次开始使用的时候，start_time = get_time_ms()

  系统调用的时候就用 (当前时间 - start_time) / 1000

记录不同系统调用的次数

+ 因为系统调用只有5个(CH2_SYSCALL_NUM) 所以通过在添加一次系统调用id 到 桶id 的映射 来计数

#### 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > 微信群的群友交流了计算系统调用时 桶计数的实现方式
   >
2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > [rCore-Tutorial-Guide 2023
   > rCore-Tutorial-Book 第三版](https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html#rcore-tutorial-book)
   >
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
