1. 页表项的组成：ppn, flags(标志位)

   flags: 

   - V(Valid)：仅当位 V 为 1 时，页表项才是合法的；
   - R(Read)/W(Write)/X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行；
   - U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
   - G：暂且不理会；
   - A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
   - D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过。

2. 缺页

   1. 缺页会造成的异常：

      StoreFault
      StorePageFault
      LoadFault
      LoadPageFault

   2. 该题借鉴了rcore-tutorial文档的参考答案

      mcause 寄存器中会保存发生中断异常的原因，其中 Exception Code 为 12 时发生指令缺页异常，为 15 时发生 store/AMO 缺页异常，为 13 时发生 load 缺页异常。

      - scause: 中断/异常发生时， CSR 寄存器 scause 中会记录其信息， Interrupt 位记录是中断还是异常， Exception Code 记录中断/异常的种类。
      - sstatus: 记录处理器当前状态，其中 SPP 段记录当前特权等级。
      - stvec: 记录处理 trap 的入口地址，现有两种模式 Direct 和 Vectored 。
      - sscratch: 其中的值是指向hart相关的S态上下文的指针，比如内核栈的指针。
      - sepc: trap 发生时会将当前指令的下一条指令地址写入其中，用于 trap 处理完成后返回。
      - stval: trap 发生进入S态时会将异常信息写入，用于帮助处理 trap ，其中会保存导致缺页异常的虚拟地址。

   3. lazy策略的好处

      + 有时候虽然需要加载到内存，但实际上不一定用的上。lazy策略可以提高内存的利用率
      + 有时候需要申请一大块内存的，此时如果一次性全部导入，会造成很大的时间开销。通过lazy策略可以将开销平摊到每次读写操作

   4. $(10 * 1024 * 1024 / 256 + 10 * 1024 * 1024 / 256 / 256) KB$

   5. 实现lazy策略

      + PTE 增加 lazy标志：表示该页还未从磁盘中加载

      + 当读取到PTE时判断lazy标志，如为 1 引发缺页异常

      + 缺页异常处理：

        保存当前任务的状态， 并从磁盘中加载对应页。同时交出cpu的使用权。

        对应页从磁盘加载完后回到刚刚引发缺页异常的指令，重新执行

   6. 将PTE标志位中的 V 置为 0

3. 单页表

   1. 如何更换页表

      同双页表

   2. 通过判断PTE标志位中的U，如为1：允许在 U 特权级时访问，否则：不行

   3. 当进行 U 态和 S 态的特权级切换的时候，不需要更换页表，同时U态的地址也能在S态被正确翻译，减少开销

   4. 双页表实现下何时更换页表：

      1. 运行下一进程时
      2. 特权级切换时

      单页表实现下何时更换页表

      1. 运行下一进程时



#### 总结实现的功能

mmap：通过直接添加一个maparea来实现

munmap：通过找到一个maparea，其满足开头页面和结尾页面等于我们的给定的 start_va 和 end_va。注：这里说的开头页面和结尾页面由 start_va.into() 和 end_va.into() 转换而来。这种实现方式存在缺陷，当给定的start_va 和 end_va 并不于maparea中的任何一个匹配，而是位于某个maparea的中间，或是由多个maparea的部分组成的时候，会出现问题



#### 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > nothing

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > nothing

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
